/*
 * FactPulse REST API
 *  REST API for electronic invoicing in France: Factur-X (CII), UBL 2.1, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Invoice Generation - **Formats**: CII XML, UBL 2.1 XML, or Factur-X PDF/A-3 - **Profiles** (CII/PDF): MINIMUM, BASIC, EN16931, EXTENDED - **UBL**: Always EN16931 compliant - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT), UBL 2.1 (OASIS) - **Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Factur-X - Validation - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules)  ### ‚úçÔ∏è Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification  ### üìã Flux 6 - Invoice Lifecycle (CDAR) - **CDAR Messages**: Acknowledgements, invoice statuses - **PPF Statuses**: REFUSED (210), PAID (212)  ### üìä Flux 10 - E-Reporting - **Tax Declarations**: International B2B, B2C - **Flow Types**: 10.1 (B2B transactions), 10.2 (B2B payments), 10.3 (B2C transactions), 10.4 (B2C payments)  ### üì° AFNOR PDP/PA (XP Z12-013) - **Flow Service**: Submit and search flows to PDPs - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user  ### üèõÔ∏è Chorus Pro - **Public Sector Invoicing**: Complete API for Chorus Pro  ### ‚è≥ Async Tasks - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **Webhooks**: Automatic notifications when tasks complete  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@factpulse.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiException;
import org.openapitools.client.model.ClientActivateResponse;
import org.openapitools.client.model.ClientCreateRequest;
import org.openapitools.client.model.ClientDetail;
import org.openapitools.client.model.ClientListResponse;
import org.openapitools.client.model.ClientUpdateRequest;
import org.openapitools.client.model.HTTPValidationError;
import org.openapitools.client.model.KeyRotationRequest;
import org.openapitools.client.model.KeyRotationResponse;
import org.openapitools.client.model.PDPConfigResponse;
import org.openapitools.client.model.PDPConfigUpdateRequest;
import java.util.UUID;
import org.openapitools.client.model.WebhookSecretDeleteResponse;
import org.openapitools.client.model.WebhookSecretGenerateResponse;
import org.openapitools.client.model.WebhookSecretStatusResponse;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for ClientManagementApi
 */
@Disabled
public class ClientManagementApiTest {

    private final ClientManagementApi api = new ClientManagementApi();

    /**
     * Activate a client
     *
     * Activate a deactivated client.  **Scope**: Client level (JWT with client_uid that must match {uid})
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void activateClientApiV1ClientsUidActiverPostTest() throws ApiException {
        UUID uid = null;
        ClientActivateResponse response = api.activateClientApiV1ClientsUidActiverPost(uid);
        // TODO: test validations
    }

    /**
     * Create a client
     *
     * Create a new client for the account.  **Scope**: Account level (JWT without client_uid)  **Fields**: - &#x60;name&#x60;: Client name (required) - &#x60;description&#x60;: Optional description - &#x60;siret&#x60;: Optional SIRET (14 digits)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void createClientApiV1ClientsPostTest() throws ApiException {
        ClientCreateRequest clientCreateRequest = null;
        ClientDetail response = api.createClientApiV1ClientsPost(clientCreateRequest);
        // TODO: test validations
    }

    /**
     * Deactivate a client
     *
     * Deactivate an active client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Note**: A deactivated client cannot be used for API calls (AFNOR, Chorus Pro, etc.).
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deactivateClientApiV1ClientsUidDesactiverPostTest() throws ApiException {
        UUID uid = null;
        ClientActivateResponse response = api.deactivateClientApiV1ClientsUidDesactiverPost(uid);
        // TODO: test validations
    }

    /**
     * Delete webhook secret
     *
     * Delete the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **After deletion**: Webhooks for this client will use the global server key for HMAC signature instead of a client-specific key.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteTest() throws ApiException {
        UUID uid = null;
        WebhookSecretDeleteResponse response = api.deleteWebhookSecretApiV1ClientsUidWebhookSecretDelete(uid);
        // TODO: test validations
    }

    /**
     * Generate webhook secret
     *
     * Generate or regenerate the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Important**: Save the returned secret immediately - it will never be shown again. The secret is used to sign webhooks sent by the server (HMAC-SHA256).  **If a secret already exists**: It will be replaced by the new one.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostTest() throws ApiException {
        UUID uid = null;
        WebhookSecretGenerateResponse response = api.generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePost(uid);
        // TODO: test validations
    }

    /**
     * Get client details
     *
     * Get details of a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: If the JWT contains a client_uid, it must match the {uid} in the URL, otherwise a 403 error is returned.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getClientApiV1ClientsUidGetTest() throws ApiException {
        UUID uid = null;
        ClientDetail response = api.getClientApiV1ClientsUidGet(uid);
        // TODO: test validations
    }

    /**
     * Get client PDP configuration
     *
     * Get the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: The client secret is never returned. Only a status (&#x60;secretStatus&#x60;) indicates whether a secret is configured.  **Response**: - If configured: all config details (URLs, client_id, secret status) - If not configured: &#x60;isConfigured: false&#x60; with a message
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPdpConfigApiV1ClientsUidPdpConfigGetTest() throws ApiException {
        UUID uid = null;
        PDPConfigResponse response = api.getPdpConfigApiV1ClientsUidPdpConfigGet(uid);
        // TODO: test validations
    }

    /**
     * Get webhook secret status
     *
     * Check if a webhook secret is configured for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Response**: - &#x60;hasSecret&#x60;: Whether a webhook secret is configured - &#x60;createdAt&#x60;: When the secret was created (if exists)  **Note**: The secret value is never returned, only its status.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetTest() throws ApiException {
        UUID uid = null;
        WebhookSecretStatusResponse response = api.getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGet(uid);
        // TODO: test validations
    }

    /**
     * List clients
     *
     * Paginated list of clients for the account.  **Scope**: Account level (JWT without client_uid)  **Pagination**: - &#x60;page&#x60;: Page number (default: 1) - &#x60;pageSize&#x60;: Page size (default: 20, max: 100)
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listClientsApiV1ClientsGetTest() throws ApiException {
        Integer page = null;
        Integer pageSize = null;
        ClientListResponse response = api.listClientsApiV1ClientsGet(page, pageSize);
        // TODO: test validations
    }

    /**
     * Rotate client encryption key
     *
     * Rotate the client encryption key for all secrets in double encryption mode.  **Scope**: Client level (JWT with client_uid that must match {uid})  **What this does**: 1. Decrypts all secrets (PDP, Chorus Pro) using the old key 2. Re-encrypts them using the new key 3. Saves to database  **Important notes**: - Both keys must be base64-encoded AES-256 keys (32 bytes each) - The old key becomes invalid immediately after rotation - Only secrets encrypted with &#x60;encryptionMode: \&quot;double\&quot;&#x60; are affected - If the client has no double-encrypted secrets, returns 404  **Security**: - The old key must be valid (decryption is verified) - If decryption fails, rotation is aborted (atomic operation) - Neither key is logged or stored by the server
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostTest() throws ApiException {
        UUID uid = null;
        KeyRotationRequest keyRotationRequest = null;
        KeyRotationResponse response = api.rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPost(uid, keyRotationRequest);
        // TODO: test validations
    }

    /**
     * Update a client
     *
     * Update client information (partial update).  **Scope**: Client level (JWT with client_uid that must match {uid})  **Updatable fields**: - &#x60;name&#x60;: Client name - &#x60;description&#x60;: Description - &#x60;siret&#x60;: SIRET (14 digits)  Only provided fields are updated.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updateClientApiV1ClientsUidPatchTest() throws ApiException {
        UUID uid = null;
        ClientUpdateRequest clientUpdateRequest = null;
        ClientDetail response = api.updateClientApiV1ClientsUidPatch(uid, clientUpdateRequest);
        // TODO: test validations
    }

    /**
     * Configure client PDP
     *
     * Configure or update the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Required fields**: - &#x60;flowServiceUrl&#x60;: PDP Flow Service URL - &#x60;tokenUrl&#x60;: PDP OAuth token URL - &#x60;oauthClientId&#x60;: OAuth Client ID - &#x60;clientSecret&#x60;: OAuth Client Secret (sent but NEVER returned)  **Optional fields**: - &#x60;isActive&#x60;: Enable/disable the config (default: true) - &#x60;modeSandbox&#x60;: Sandbox mode (default: false) - &#x60;encryptionMode&#x60;: Encryption mode (default: \&quot;fernet\&quot;)   - \&quot;fernet\&quot;: Server-side encryption only   - \&quot;double\&quot;: Client AES-256-GCM + Server Fernet (requires X-Encryption-Key header)  **Double Encryption Mode**: When &#x60;encryptionMode&#x60; is set to \&quot;double\&quot;, you MUST also provide the &#x60;X-Encryption-Key&#x60; header containing a base64-encoded AES-256 key (32 bytes). This key is used to encrypt the &#x60;clientSecret&#x60; on the client side before the server encrypts it again with Fernet. The server cannot decrypt the secret without the client key.  **Security**: The &#x60;clientSecret&#x60; is stored encrypted on Django side and is never returned in API responses.
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void updatePdpConfigApiV1ClientsUidPdpConfigPutTest() throws ApiException {
        UUID uid = null;
        PDPConfigUpdateRequest pdPConfigUpdateRequest = null;
        String xEncryptionKey = null;
        PDPConfigResponse response = api.updatePdpConfigApiV1ClientsUidPdpConfigPut(uid, pdPConfigUpdateRequest, xEncryptionKey);
        // TODO: test validations
    }

}
