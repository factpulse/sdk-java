/*
 * FactPulse REST API
 *  REST API for electronic invoicing in France: Factur-X (CII), UBL 2.1, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Invoice Generation - **Formats**: CII XML, UBL 2.1 XML, or Factur-X PDF/A-3 - **Profiles** (CII/PDF): MINIMUM, BASIC, EN16931, EXTENDED - **UBL**: Always EN16931 compliant - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT), UBL 2.1 (OASIS) - **Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Factur-X - Validation - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules)  ### ‚úçÔ∏è Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification  ### üìã Flux 6 - Invoice Lifecycle (CDAR) - **CDAR Messages**: Acknowledgements, invoice statuses - **PPF Statuses**: REFUSED (210), PAID (212)  ### üìä Flux 10 - E-Reporting - **Tax Declarations**: International B2B, B2C - **Flow Types**: 10.1 (B2B transactions), 10.2 (B2B payments), 10.3 (B2C transactions), 10.4 (B2C payments)  ### üì° AFNOR PDP/PA (XP Z12-013) - **Flow Service**: Submit and search flows to PDPs - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user  ### üèõÔ∏è Chorus Pro - **Public Sector Invoicing**: Complete API for Chorus Pro  ### ‚è≥ Async Tasks - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **Webhooks**: Automatic notifications when tasks complete  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@factpulse.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.api;

import org.openapitools.client.ApiCallback;
import org.openapitools.client.ApiClient;
import org.openapitools.client.ApiException;
import org.openapitools.client.ApiResponse;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;
import org.openapitools.client.ProgressRequestBody;
import org.openapitools.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import org.openapitools.client.model.ClientActivateResponse;
import org.openapitools.client.model.ClientCreateRequest;
import org.openapitools.client.model.ClientDetail;
import org.openapitools.client.model.ClientListResponse;
import org.openapitools.client.model.ClientUpdateRequest;
import org.openapitools.client.model.HTTPValidationError;
import org.openapitools.client.model.KeyRotationRequest;
import org.openapitools.client.model.KeyRotationResponse;
import org.openapitools.client.model.PDPConfigResponse;
import org.openapitools.client.model.PDPConfigUpdateRequest;
import java.util.UUID;
import org.openapitools.client.model.WebhookSecretDeleteResponse;
import org.openapitools.client.model.WebhookSecretGenerateResponse;
import org.openapitools.client.model.WebhookSecretStatusResponse;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ClientManagementApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ClientManagementApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ClientManagementApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for activateClientApiV1ClientsUidActiverPost
     * @param uid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call activateClientApiV1ClientsUidActiverPostCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/activer"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call activateClientApiV1ClientsUidActiverPostValidateBeforeCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling activateClientApiV1ClientsUidActiverPost(Async)");
        }

        return activateClientApiV1ClientsUidActiverPostCall(uid, _callback);

    }

    /**
     * Activate a client
     * Activate a deactivated client.  **Scope**: Client level (JWT with client_uid that must match {uid})
     * @param uid  (required)
     * @return ClientActivateResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ClientActivateResponse activateClientApiV1ClientsUidActiverPost(@javax.annotation.Nonnull UUID uid) throws ApiException {
        ApiResponse<ClientActivateResponse> localVarResp = activateClientApiV1ClientsUidActiverPostWithHttpInfo(uid);
        return localVarResp.getData();
    }

    /**
     * Activate a client
     * Activate a deactivated client.  **Scope**: Client level (JWT with client_uid that must match {uid})
     * @param uid  (required)
     * @return ApiResponse&lt;ClientActivateResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClientActivateResponse> activateClientApiV1ClientsUidActiverPostWithHttpInfo(@javax.annotation.Nonnull UUID uid) throws ApiException {
        okhttp3.Call localVarCall = activateClientApiV1ClientsUidActiverPostValidateBeforeCall(uid, null);
        Type localVarReturnType = new TypeToken<ClientActivateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Activate a client (asynchronously)
     * Activate a deactivated client.  **Scope**: Client level (JWT with client_uid that must match {uid})
     * @param uid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call activateClientApiV1ClientsUidActiverPostAsync(@javax.annotation.Nonnull UUID uid, final ApiCallback<ClientActivateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = activateClientApiV1ClientsUidActiverPostValidateBeforeCall(uid, _callback);
        Type localVarReturnType = new TypeToken<ClientActivateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createClientApiV1ClientsPost
     * @param clientCreateRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createClientApiV1ClientsPostCall(@javax.annotation.Nonnull ClientCreateRequest clientCreateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = clientCreateRequest;

        // create path and map variables
        String localVarPath = "/api/v1/clients";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createClientApiV1ClientsPostValidateBeforeCall(@javax.annotation.Nonnull ClientCreateRequest clientCreateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'clientCreateRequest' is set
        if (clientCreateRequest == null) {
            throw new ApiException("Missing the required parameter 'clientCreateRequest' when calling createClientApiV1ClientsPost(Async)");
        }

        return createClientApiV1ClientsPostCall(clientCreateRequest, _callback);

    }

    /**
     * Create a client
     * Create a new client for the account.  **Scope**: Account level (JWT without client_uid)  **Fields**: - &#x60;name&#x60;: Client name (required) - &#x60;description&#x60;: Optional description - &#x60;siret&#x60;: Optional SIRET (14 digits)
     * @param clientCreateRequest  (required)
     * @return ClientDetail
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ClientDetail createClientApiV1ClientsPost(@javax.annotation.Nonnull ClientCreateRequest clientCreateRequest) throws ApiException {
        ApiResponse<ClientDetail> localVarResp = createClientApiV1ClientsPostWithHttpInfo(clientCreateRequest);
        return localVarResp.getData();
    }

    /**
     * Create a client
     * Create a new client for the account.  **Scope**: Account level (JWT without client_uid)  **Fields**: - &#x60;name&#x60;: Client name (required) - &#x60;description&#x60;: Optional description - &#x60;siret&#x60;: Optional SIRET (14 digits)
     * @param clientCreateRequest  (required)
     * @return ApiResponse&lt;ClientDetail&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClientDetail> createClientApiV1ClientsPostWithHttpInfo(@javax.annotation.Nonnull ClientCreateRequest clientCreateRequest) throws ApiException {
        okhttp3.Call localVarCall = createClientApiV1ClientsPostValidateBeforeCall(clientCreateRequest, null);
        Type localVarReturnType = new TypeToken<ClientDetail>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Create a client (asynchronously)
     * Create a new client for the account.  **Scope**: Account level (JWT without client_uid)  **Fields**: - &#x60;name&#x60;: Client name (required) - &#x60;description&#x60;: Optional description - &#x60;siret&#x60;: Optional SIRET (14 digits)
     * @param clientCreateRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 201 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call createClientApiV1ClientsPostAsync(@javax.annotation.Nonnull ClientCreateRequest clientCreateRequest, final ApiCallback<ClientDetail> _callback) throws ApiException {

        okhttp3.Call localVarCall = createClientApiV1ClientsPostValidateBeforeCall(clientCreateRequest, _callback);
        Type localVarReturnType = new TypeToken<ClientDetail>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deactivateClientApiV1ClientsUidDesactiverPost
     * @param uid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deactivateClientApiV1ClientsUidDesactiverPostCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/desactiver"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deactivateClientApiV1ClientsUidDesactiverPostValidateBeforeCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling deactivateClientApiV1ClientsUidDesactiverPost(Async)");
        }

        return deactivateClientApiV1ClientsUidDesactiverPostCall(uid, _callback);

    }

    /**
     * Deactivate a client
     * Deactivate an active client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Note**: A deactivated client cannot be used for API calls (AFNOR, Chorus Pro, etc.).
     * @param uid  (required)
     * @return ClientActivateResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ClientActivateResponse deactivateClientApiV1ClientsUidDesactiverPost(@javax.annotation.Nonnull UUID uid) throws ApiException {
        ApiResponse<ClientActivateResponse> localVarResp = deactivateClientApiV1ClientsUidDesactiverPostWithHttpInfo(uid);
        return localVarResp.getData();
    }

    /**
     * Deactivate a client
     * Deactivate an active client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Note**: A deactivated client cannot be used for API calls (AFNOR, Chorus Pro, etc.).
     * @param uid  (required)
     * @return ApiResponse&lt;ClientActivateResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClientActivateResponse> deactivateClientApiV1ClientsUidDesactiverPostWithHttpInfo(@javax.annotation.Nonnull UUID uid) throws ApiException {
        okhttp3.Call localVarCall = deactivateClientApiV1ClientsUidDesactiverPostValidateBeforeCall(uid, null);
        Type localVarReturnType = new TypeToken<ClientActivateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Deactivate a client (asynchronously)
     * Deactivate an active client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Note**: A deactivated client cannot be used for API calls (AFNOR, Chorus Pro, etc.).
     * @param uid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deactivateClientApiV1ClientsUidDesactiverPostAsync(@javax.annotation.Nonnull UUID uid, final ApiCallback<ClientActivateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deactivateClientApiV1ClientsUidDesactiverPostValidateBeforeCall(uid, _callback);
        Type localVarReturnType = new TypeToken<ClientActivateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteWebhookSecretApiV1ClientsUidWebhookSecretDelete
     * @param uid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/webhook-secret"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteValidateBeforeCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling deleteWebhookSecretApiV1ClientsUidWebhookSecretDelete(Async)");
        }

        return deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteCall(uid, _callback);

    }

    /**
     * Delete webhook secret
     * Delete the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **After deletion**: Webhooks for this client will use the global server key for HMAC signature instead of a client-specific key.
     * @param uid  (required)
     * @return WebhookSecretDeleteResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public WebhookSecretDeleteResponse deleteWebhookSecretApiV1ClientsUidWebhookSecretDelete(@javax.annotation.Nonnull UUID uid) throws ApiException {
        ApiResponse<WebhookSecretDeleteResponse> localVarResp = deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteWithHttpInfo(uid);
        return localVarResp.getData();
    }

    /**
     * Delete webhook secret
     * Delete the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **After deletion**: Webhooks for this client will use the global server key for HMAC signature instead of a client-specific key.
     * @param uid  (required)
     * @return ApiResponse&lt;WebhookSecretDeleteResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WebhookSecretDeleteResponse> deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteWithHttpInfo(@javax.annotation.Nonnull UUID uid) throws ApiException {
        okhttp3.Call localVarCall = deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteValidateBeforeCall(uid, null);
        Type localVarReturnType = new TypeToken<WebhookSecretDeleteResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Delete webhook secret (asynchronously)
     * Delete the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **After deletion**: Webhooks for this client will use the global server key for HMAC signature instead of a client-specific key.
     * @param uid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteAsync(@javax.annotation.Nonnull UUID uid, final ApiCallback<WebhookSecretDeleteResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteWebhookSecretApiV1ClientsUidWebhookSecretDeleteValidateBeforeCall(uid, _callback);
        Type localVarReturnType = new TypeToken<WebhookSecretDeleteResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePost
     * @param uid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/webhook-secret/generate"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostValidateBeforeCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePost(Async)");
        }

        return generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostCall(uid, _callback);

    }

    /**
     * Generate webhook secret
     * Generate or regenerate the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Important**: Save the returned secret immediately - it will never be shown again. The secret is used to sign webhooks sent by the server (HMAC-SHA256).  **If a secret already exists**: It will be replaced by the new one.
     * @param uid  (required)
     * @return WebhookSecretGenerateResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public WebhookSecretGenerateResponse generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePost(@javax.annotation.Nonnull UUID uid) throws ApiException {
        ApiResponse<WebhookSecretGenerateResponse> localVarResp = generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostWithHttpInfo(uid);
        return localVarResp.getData();
    }

    /**
     * Generate webhook secret
     * Generate or regenerate the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Important**: Save the returned secret immediately - it will never be shown again. The secret is used to sign webhooks sent by the server (HMAC-SHA256).  **If a secret already exists**: It will be replaced by the new one.
     * @param uid  (required)
     * @return ApiResponse&lt;WebhookSecretGenerateResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WebhookSecretGenerateResponse> generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostWithHttpInfo(@javax.annotation.Nonnull UUID uid) throws ApiException {
        okhttp3.Call localVarCall = generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostValidateBeforeCall(uid, null);
        Type localVarReturnType = new TypeToken<WebhookSecretGenerateResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Generate webhook secret (asynchronously)
     * Generate or regenerate the webhook secret for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Important**: Save the returned secret immediately - it will never be shown again. The secret is used to sign webhooks sent by the server (HMAC-SHA256).  **If a secret already exists**: It will be replaced by the new one.
     * @param uid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostAsync(@javax.annotation.Nonnull UUID uid, final ApiCallback<WebhookSecretGenerateResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = generateWebhookSecretApiV1ClientsUidWebhookSecretGeneratePostValidateBeforeCall(uid, _callback);
        Type localVarReturnType = new TypeToken<WebhookSecretGenerateResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getClientApiV1ClientsUidGet
     * @param uid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getClientApiV1ClientsUidGetCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getClientApiV1ClientsUidGetValidateBeforeCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling getClientApiV1ClientsUidGet(Async)");
        }

        return getClientApiV1ClientsUidGetCall(uid, _callback);

    }

    /**
     * Get client details
     * Get details of a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: If the JWT contains a client_uid, it must match the {uid} in the URL, otherwise a 403 error is returned.
     * @param uid  (required)
     * @return ClientDetail
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ClientDetail getClientApiV1ClientsUidGet(@javax.annotation.Nonnull UUID uid) throws ApiException {
        ApiResponse<ClientDetail> localVarResp = getClientApiV1ClientsUidGetWithHttpInfo(uid);
        return localVarResp.getData();
    }

    /**
     * Get client details
     * Get details of a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: If the JWT contains a client_uid, it must match the {uid} in the URL, otherwise a 403 error is returned.
     * @param uid  (required)
     * @return ApiResponse&lt;ClientDetail&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClientDetail> getClientApiV1ClientsUidGetWithHttpInfo(@javax.annotation.Nonnull UUID uid) throws ApiException {
        okhttp3.Call localVarCall = getClientApiV1ClientsUidGetValidateBeforeCall(uid, null);
        Type localVarReturnType = new TypeToken<ClientDetail>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get client details (asynchronously)
     * Get details of a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: If the JWT contains a client_uid, it must match the {uid} in the URL, otherwise a 403 error is returned.
     * @param uid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getClientApiV1ClientsUidGetAsync(@javax.annotation.Nonnull UUID uid, final ApiCallback<ClientDetail> _callback) throws ApiException {

        okhttp3.Call localVarCall = getClientApiV1ClientsUidGetValidateBeforeCall(uid, _callback);
        Type localVarReturnType = new TypeToken<ClientDetail>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getPdpConfigApiV1ClientsUidPdpConfigGet
     * @param uid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPdpConfigApiV1ClientsUidPdpConfigGetCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/pdp-config"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPdpConfigApiV1ClientsUidPdpConfigGetValidateBeforeCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling getPdpConfigApiV1ClientsUidPdpConfigGet(Async)");
        }

        return getPdpConfigApiV1ClientsUidPdpConfigGetCall(uid, _callback);

    }

    /**
     * Get client PDP configuration
     * Get the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: The client secret is never returned. Only a status (&#x60;secretStatus&#x60;) indicates whether a secret is configured.  **Response**: - If configured: all config details (URLs, client_id, secret status) - If not configured: &#x60;isConfigured: false&#x60; with a message
     * @param uid  (required)
     * @return PDPConfigResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public PDPConfigResponse getPdpConfigApiV1ClientsUidPdpConfigGet(@javax.annotation.Nonnull UUID uid) throws ApiException {
        ApiResponse<PDPConfigResponse> localVarResp = getPdpConfigApiV1ClientsUidPdpConfigGetWithHttpInfo(uid);
        return localVarResp.getData();
    }

    /**
     * Get client PDP configuration
     * Get the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: The client secret is never returned. Only a status (&#x60;secretStatus&#x60;) indicates whether a secret is configured.  **Response**: - If configured: all config details (URLs, client_id, secret status) - If not configured: &#x60;isConfigured: false&#x60; with a message
     * @param uid  (required)
     * @return ApiResponse&lt;PDPConfigResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PDPConfigResponse> getPdpConfigApiV1ClientsUidPdpConfigGetWithHttpInfo(@javax.annotation.Nonnull UUID uid) throws ApiException {
        okhttp3.Call localVarCall = getPdpConfigApiV1ClientsUidPdpConfigGetValidateBeforeCall(uid, null);
        Type localVarReturnType = new TypeToken<PDPConfigResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get client PDP configuration (asynchronously)
     * Get the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Security**: The client secret is never returned. Only a status (&#x60;secretStatus&#x60;) indicates whether a secret is configured.  **Response**: - If configured: all config details (URLs, client_id, secret status) - If not configured: &#x60;isConfigured: false&#x60; with a message
     * @param uid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getPdpConfigApiV1ClientsUidPdpConfigGetAsync(@javax.annotation.Nonnull UUID uid, final ApiCallback<PDPConfigResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPdpConfigApiV1ClientsUidPdpConfigGetValidateBeforeCall(uid, _callback);
        Type localVarReturnType = new TypeToken<PDPConfigResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGet
     * @param uid  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/webhook-secret/status"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetValidateBeforeCall(@javax.annotation.Nonnull UUID uid, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGet(Async)");
        }

        return getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetCall(uid, _callback);

    }

    /**
     * Get webhook secret status
     * Check if a webhook secret is configured for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Response**: - &#x60;hasSecret&#x60;: Whether a webhook secret is configured - &#x60;createdAt&#x60;: When the secret was created (if exists)  **Note**: The secret value is never returned, only its status.
     * @param uid  (required)
     * @return WebhookSecretStatusResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public WebhookSecretStatusResponse getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGet(@javax.annotation.Nonnull UUID uid) throws ApiException {
        ApiResponse<WebhookSecretStatusResponse> localVarResp = getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetWithHttpInfo(uid);
        return localVarResp.getData();
    }

    /**
     * Get webhook secret status
     * Check if a webhook secret is configured for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Response**: - &#x60;hasSecret&#x60;: Whether a webhook secret is configured - &#x60;createdAt&#x60;: When the secret was created (if exists)  **Note**: The secret value is never returned, only its status.
     * @param uid  (required)
     * @return ApiResponse&lt;WebhookSecretStatusResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<WebhookSecretStatusResponse> getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetWithHttpInfo(@javax.annotation.Nonnull UUID uid) throws ApiException {
        okhttp3.Call localVarCall = getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetValidateBeforeCall(uid, null);
        Type localVarReturnType = new TypeToken<WebhookSecretStatusResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get webhook secret status (asynchronously)
     * Check if a webhook secret is configured for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Response**: - &#x60;hasSecret&#x60;: Whether a webhook secret is configured - &#x60;createdAt&#x60;: When the secret was created (if exists)  **Note**: The secret value is never returned, only its status.
     * @param uid  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetAsync(@javax.annotation.Nonnull UUID uid, final ApiCallback<WebhookSecretStatusResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWebhookSecretStatusApiV1ClientsUidWebhookSecretStatusGetValidateBeforeCall(uid, _callback);
        Type localVarReturnType = new TypeToken<WebhookSecretStatusResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for listClientsApiV1ClientsGet
     * @param page Page number (optional, default to 1)
     * @param pageSize Page size (optional, default to 20)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listClientsApiV1ClientsGetCall(@javax.annotation.Nullable Integer page, @javax.annotation.Nullable Integer pageSize, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/v1/clients";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (pageSize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pageSize", pageSize));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listClientsApiV1ClientsGetValidateBeforeCall(@javax.annotation.Nullable Integer page, @javax.annotation.Nullable Integer pageSize, final ApiCallback _callback) throws ApiException {
        return listClientsApiV1ClientsGetCall(page, pageSize, _callback);

    }

    /**
     * List clients
     * Paginated list of clients for the account.  **Scope**: Account level (JWT without client_uid)  **Pagination**: - &#x60;page&#x60;: Page number (default: 1) - &#x60;pageSize&#x60;: Page size (default: 20, max: 100)
     * @param page Page number (optional, default to 1)
     * @param pageSize Page size (optional, default to 20)
     * @return ClientListResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ClientListResponse listClientsApiV1ClientsGet(@javax.annotation.Nullable Integer page, @javax.annotation.Nullable Integer pageSize) throws ApiException {
        ApiResponse<ClientListResponse> localVarResp = listClientsApiV1ClientsGetWithHttpInfo(page, pageSize);
        return localVarResp.getData();
    }

    /**
     * List clients
     * Paginated list of clients for the account.  **Scope**: Account level (JWT without client_uid)  **Pagination**: - &#x60;page&#x60;: Page number (default: 1) - &#x60;pageSize&#x60;: Page size (default: 20, max: 100)
     * @param page Page number (optional, default to 1)
     * @param pageSize Page size (optional, default to 20)
     * @return ApiResponse&lt;ClientListResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClientListResponse> listClientsApiV1ClientsGetWithHttpInfo(@javax.annotation.Nullable Integer page, @javax.annotation.Nullable Integer pageSize) throws ApiException {
        okhttp3.Call localVarCall = listClientsApiV1ClientsGetValidateBeforeCall(page, pageSize, null);
        Type localVarReturnType = new TypeToken<ClientListResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * List clients (asynchronously)
     * Paginated list of clients for the account.  **Scope**: Account level (JWT without client_uid)  **Pagination**: - &#x60;page&#x60;: Page number (default: 1) - &#x60;pageSize&#x60;: Page size (default: 20, max: 100)
     * @param page Page number (optional, default to 1)
     * @param pageSize Page size (optional, default to 20)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call listClientsApiV1ClientsGetAsync(@javax.annotation.Nullable Integer page, @javax.annotation.Nullable Integer pageSize, final ApiCallback<ClientListResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = listClientsApiV1ClientsGetValidateBeforeCall(page, pageSize, _callback);
        Type localVarReturnType = new TypeToken<ClientListResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPost
     * @param uid  (required)
     * @param keyRotationRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostCall(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull KeyRotationRequest keyRotationRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = keyRotationRequest;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/rotate-encryption-key"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostValidateBeforeCall(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull KeyRotationRequest keyRotationRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPost(Async)");
        }

        // verify the required parameter 'keyRotationRequest' is set
        if (keyRotationRequest == null) {
            throw new ApiException("Missing the required parameter 'keyRotationRequest' when calling rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPost(Async)");
        }

        return rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostCall(uid, keyRotationRequest, _callback);

    }

    /**
     * Rotate client encryption key
     * Rotate the client encryption key for all secrets in double encryption mode.  **Scope**: Client level (JWT with client_uid that must match {uid})  **What this does**: 1. Decrypts all secrets (PDP, Chorus Pro) using the old key 2. Re-encrypts them using the new key 3. Saves to database  **Important notes**: - Both keys must be base64-encoded AES-256 keys (32 bytes each) - The old key becomes invalid immediately after rotation - Only secrets encrypted with &#x60;encryptionMode: \&quot;double\&quot;&#x60; are affected - If the client has no double-encrypted secrets, returns 404  **Security**: - The old key must be valid (decryption is verified) - If decryption fails, rotation is aborted (atomic operation) - Neither key is logged or stored by the server
     * @param uid  (required)
     * @param keyRotationRequest  (required)
     * @return KeyRotationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public KeyRotationResponse rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPost(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull KeyRotationRequest keyRotationRequest) throws ApiException {
        ApiResponse<KeyRotationResponse> localVarResp = rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostWithHttpInfo(uid, keyRotationRequest);
        return localVarResp.getData();
    }

    /**
     * Rotate client encryption key
     * Rotate the client encryption key for all secrets in double encryption mode.  **Scope**: Client level (JWT with client_uid that must match {uid})  **What this does**: 1. Decrypts all secrets (PDP, Chorus Pro) using the old key 2. Re-encrypts them using the new key 3. Saves to database  **Important notes**: - Both keys must be base64-encoded AES-256 keys (32 bytes each) - The old key becomes invalid immediately after rotation - Only secrets encrypted with &#x60;encryptionMode: \&quot;double\&quot;&#x60; are affected - If the client has no double-encrypted secrets, returns 404  **Security**: - The old key must be valid (decryption is verified) - If decryption fails, rotation is aborted (atomic operation) - Neither key is logged or stored by the server
     * @param uid  (required)
     * @param keyRotationRequest  (required)
     * @return ApiResponse&lt;KeyRotationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<KeyRotationResponse> rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostWithHttpInfo(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull KeyRotationRequest keyRotationRequest) throws ApiException {
        okhttp3.Call localVarCall = rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostValidateBeforeCall(uid, keyRotationRequest, null);
        Type localVarReturnType = new TypeToken<KeyRotationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Rotate client encryption key (asynchronously)
     * Rotate the client encryption key for all secrets in double encryption mode.  **Scope**: Client level (JWT with client_uid that must match {uid})  **What this does**: 1. Decrypts all secrets (PDP, Chorus Pro) using the old key 2. Re-encrypts them using the new key 3. Saves to database  **Important notes**: - Both keys must be base64-encoded AES-256 keys (32 bytes each) - The old key becomes invalid immediately after rotation - Only secrets encrypted with &#x60;encryptionMode: \&quot;double\&quot;&#x60; are affected - If the client has no double-encrypted secrets, returns 404  **Security**: - The old key must be valid (decryption is verified) - If decryption fails, rotation is aborted (atomic operation) - Neither key is logged or stored by the server
     * @param uid  (required)
     * @param keyRotationRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostAsync(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull KeyRotationRequest keyRotationRequest, final ApiCallback<KeyRotationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = rotateEncryptionKeyApiV1ClientsUidRotateEncryptionKeyPostValidateBeforeCall(uid, keyRotationRequest, _callback);
        Type localVarReturnType = new TypeToken<KeyRotationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateClientApiV1ClientsUidPatch
     * @param uid  (required)
     * @param clientUpdateRequest  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateClientApiV1ClientsUidPatchCall(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull ClientUpdateRequest clientUpdateRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = clientUpdateRequest;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PATCH", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateClientApiV1ClientsUidPatchValidateBeforeCall(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull ClientUpdateRequest clientUpdateRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling updateClientApiV1ClientsUidPatch(Async)");
        }

        // verify the required parameter 'clientUpdateRequest' is set
        if (clientUpdateRequest == null) {
            throw new ApiException("Missing the required parameter 'clientUpdateRequest' when calling updateClientApiV1ClientsUidPatch(Async)");
        }

        return updateClientApiV1ClientsUidPatchCall(uid, clientUpdateRequest, _callback);

    }

    /**
     * Update a client
     * Update client information (partial update).  **Scope**: Client level (JWT with client_uid that must match {uid})  **Updatable fields**: - &#x60;name&#x60;: Client name - &#x60;description&#x60;: Description - &#x60;siret&#x60;: SIRET (14 digits)  Only provided fields are updated.
     * @param uid  (required)
     * @param clientUpdateRequest  (required)
     * @return ClientDetail
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ClientDetail updateClientApiV1ClientsUidPatch(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull ClientUpdateRequest clientUpdateRequest) throws ApiException {
        ApiResponse<ClientDetail> localVarResp = updateClientApiV1ClientsUidPatchWithHttpInfo(uid, clientUpdateRequest);
        return localVarResp.getData();
    }

    /**
     * Update a client
     * Update client information (partial update).  **Scope**: Client level (JWT with client_uid that must match {uid})  **Updatable fields**: - &#x60;name&#x60;: Client name - &#x60;description&#x60;: Description - &#x60;siret&#x60;: SIRET (14 digits)  Only provided fields are updated.
     * @param uid  (required)
     * @param clientUpdateRequest  (required)
     * @return ApiResponse&lt;ClientDetail&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ClientDetail> updateClientApiV1ClientsUidPatchWithHttpInfo(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull ClientUpdateRequest clientUpdateRequest) throws ApiException {
        okhttp3.Call localVarCall = updateClientApiV1ClientsUidPatchValidateBeforeCall(uid, clientUpdateRequest, null);
        Type localVarReturnType = new TypeToken<ClientDetail>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Update a client (asynchronously)
     * Update client information (partial update).  **Scope**: Client level (JWT with client_uid that must match {uid})  **Updatable fields**: - &#x60;name&#x60;: Client name - &#x60;description&#x60;: Description - &#x60;siret&#x60;: SIRET (14 digits)  Only provided fields are updated.
     * @param uid  (required)
     * @param clientUpdateRequest  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updateClientApiV1ClientsUidPatchAsync(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull ClientUpdateRequest clientUpdateRequest, final ApiCallback<ClientDetail> _callback) throws ApiException {

        okhttp3.Call localVarCall = updateClientApiV1ClientsUidPatchValidateBeforeCall(uid, clientUpdateRequest, _callback);
        Type localVarReturnType = new TypeToken<ClientDetail>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updatePdpConfigApiV1ClientsUidPdpConfigPut
     * @param uid  (required)
     * @param pdPConfigUpdateRequest  (required)
     * @param xEncryptionKey Client encryption key for double encryption mode. Must be a base64-encoded AES-256 key (32 bytes). Required only when accessing resources encrypted with encryption_mode&#x3D;&#39;double&#39;. (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updatePdpConfigApiV1ClientsUidPdpConfigPutCall(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull PDPConfigUpdateRequest pdPConfigUpdateRequest, @javax.annotation.Nullable String xEncryptionKey, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = pdPConfigUpdateRequest;

        // create path and map variables
        String localVarPath = "/api/v1/clients/{uid}/pdp-config"
            .replace("{" + "uid" + "}", localVarApiClient.escapeString(uid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (xEncryptionKey != null) {
            localVarHeaderParams.put("X-Encryption-Key", localVarApiClient.parameterToString(xEncryptionKey));
        }


        String[] localVarAuthNames = new String[] { "APIKeyHeader", "HTTPBearer" };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updatePdpConfigApiV1ClientsUidPdpConfigPutValidateBeforeCall(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull PDPConfigUpdateRequest pdPConfigUpdateRequest, @javax.annotation.Nullable String xEncryptionKey, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'uid' is set
        if (uid == null) {
            throw new ApiException("Missing the required parameter 'uid' when calling updatePdpConfigApiV1ClientsUidPdpConfigPut(Async)");
        }

        // verify the required parameter 'pdPConfigUpdateRequest' is set
        if (pdPConfigUpdateRequest == null) {
            throw new ApiException("Missing the required parameter 'pdPConfigUpdateRequest' when calling updatePdpConfigApiV1ClientsUidPdpConfigPut(Async)");
        }

        return updatePdpConfigApiV1ClientsUidPdpConfigPutCall(uid, pdPConfigUpdateRequest, xEncryptionKey, _callback);

    }

    /**
     * Configure client PDP
     * Configure or update the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Required fields**: - &#x60;flowServiceUrl&#x60;: PDP Flow Service URL - &#x60;tokenUrl&#x60;: PDP OAuth token URL - &#x60;oauthClientId&#x60;: OAuth Client ID - &#x60;clientSecret&#x60;: OAuth Client Secret (sent but NEVER returned)  **Optional fields**: - &#x60;isActive&#x60;: Enable/disable the config (default: true) - &#x60;modeSandbox&#x60;: Sandbox mode (default: false) - &#x60;encryptionMode&#x60;: Encryption mode (default: \&quot;fernet\&quot;)   - \&quot;fernet\&quot;: Server-side encryption only   - \&quot;double\&quot;: Client AES-256-GCM + Server Fernet (requires X-Encryption-Key header)  **Double Encryption Mode**: When &#x60;encryptionMode&#x60; is set to \&quot;double\&quot;, you MUST also provide the &#x60;X-Encryption-Key&#x60; header containing a base64-encoded AES-256 key (32 bytes). This key is used to encrypt the &#x60;clientSecret&#x60; on the client side before the server encrypts it again with Fernet. The server cannot decrypt the secret without the client key.  **Security**: The &#x60;clientSecret&#x60; is stored encrypted on Django side and is never returned in API responses.
     * @param uid  (required)
     * @param pdPConfigUpdateRequest  (required)
     * @param xEncryptionKey Client encryption key for double encryption mode. Must be a base64-encoded AES-256 key (32 bytes). Required only when accessing resources encrypted with encryption_mode&#x3D;&#39;double&#39;. (optional)
     * @return PDPConfigResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public PDPConfigResponse updatePdpConfigApiV1ClientsUidPdpConfigPut(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull PDPConfigUpdateRequest pdPConfigUpdateRequest, @javax.annotation.Nullable String xEncryptionKey) throws ApiException {
        ApiResponse<PDPConfigResponse> localVarResp = updatePdpConfigApiV1ClientsUidPdpConfigPutWithHttpInfo(uid, pdPConfigUpdateRequest, xEncryptionKey);
        return localVarResp.getData();
    }

    /**
     * Configure client PDP
     * Configure or update the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Required fields**: - &#x60;flowServiceUrl&#x60;: PDP Flow Service URL - &#x60;tokenUrl&#x60;: PDP OAuth token URL - &#x60;oauthClientId&#x60;: OAuth Client ID - &#x60;clientSecret&#x60;: OAuth Client Secret (sent but NEVER returned)  **Optional fields**: - &#x60;isActive&#x60;: Enable/disable the config (default: true) - &#x60;modeSandbox&#x60;: Sandbox mode (default: false) - &#x60;encryptionMode&#x60;: Encryption mode (default: \&quot;fernet\&quot;)   - \&quot;fernet\&quot;: Server-side encryption only   - \&quot;double\&quot;: Client AES-256-GCM + Server Fernet (requires X-Encryption-Key header)  **Double Encryption Mode**: When &#x60;encryptionMode&#x60; is set to \&quot;double\&quot;, you MUST also provide the &#x60;X-Encryption-Key&#x60; header containing a base64-encoded AES-256 key (32 bytes). This key is used to encrypt the &#x60;clientSecret&#x60; on the client side before the server encrypts it again with Fernet. The server cannot decrypt the secret without the client key.  **Security**: The &#x60;clientSecret&#x60; is stored encrypted on Django side and is never returned in API responses.
     * @param uid  (required)
     * @param pdPConfigUpdateRequest  (required)
     * @param xEncryptionKey Client encryption key for double encryption mode. Must be a base64-encoded AES-256 key (32 bytes). Required only when accessing resources encrypted with encryption_mode&#x3D;&#39;double&#39;. (optional)
     * @return ApiResponse&lt;PDPConfigResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<PDPConfigResponse> updatePdpConfigApiV1ClientsUidPdpConfigPutWithHttpInfo(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull PDPConfigUpdateRequest pdPConfigUpdateRequest, @javax.annotation.Nullable String xEncryptionKey) throws ApiException {
        okhttp3.Call localVarCall = updatePdpConfigApiV1ClientsUidPdpConfigPutValidateBeforeCall(uid, pdPConfigUpdateRequest, xEncryptionKey, null);
        Type localVarReturnType = new TypeToken<PDPConfigResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Configure client PDP (asynchronously)
     * Configure or update the PDP (PA/PDP) configuration for a client.  **Scope**: Client level (JWT with client_uid that must match {uid})  **Required fields**: - &#x60;flowServiceUrl&#x60;: PDP Flow Service URL - &#x60;tokenUrl&#x60;: PDP OAuth token URL - &#x60;oauthClientId&#x60;: OAuth Client ID - &#x60;clientSecret&#x60;: OAuth Client Secret (sent but NEVER returned)  **Optional fields**: - &#x60;isActive&#x60;: Enable/disable the config (default: true) - &#x60;modeSandbox&#x60;: Sandbox mode (default: false) - &#x60;encryptionMode&#x60;: Encryption mode (default: \&quot;fernet\&quot;)   - \&quot;fernet\&quot;: Server-side encryption only   - \&quot;double\&quot;: Client AES-256-GCM + Server Fernet (requires X-Encryption-Key header)  **Double Encryption Mode**: When &#x60;encryptionMode&#x60; is set to \&quot;double\&quot;, you MUST also provide the &#x60;X-Encryption-Key&#x60; header containing a base64-encoded AES-256 key (32 bytes). This key is used to encrypt the &#x60;clientSecret&#x60; on the client side before the server encrypts it again with Fernet. The server cannot decrypt the secret without the client key.  **Security**: The &#x60;clientSecret&#x60; is stored encrypted on Django side and is never returned in API responses.
     * @param uid  (required)
     * @param pdPConfigUpdateRequest  (required)
     * @param xEncryptionKey Client encryption key for double encryption mode. Must be a base64-encoded AES-256 key (32 bytes). Required only when accessing resources encrypted with encryption_mode&#x3D;&#39;double&#39;. (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> Successful Response </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Invalid request </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing or invalid JWT token </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> Access denied </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> Client not found </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> Server error </td><td>  -  </td></tr>
        <tr><td> 422 </td><td> Validation Error </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call updatePdpConfigApiV1ClientsUidPdpConfigPutAsync(@javax.annotation.Nonnull UUID uid, @javax.annotation.Nonnull PDPConfigUpdateRequest pdPConfigUpdateRequest, @javax.annotation.Nullable String xEncryptionKey, final ApiCallback<PDPConfigResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = updatePdpConfigApiV1ClientsUidPdpConfigPutValidateBeforeCall(uid, pdPConfigUpdateRequest, xEncryptionKey, _callback);
        Type localVarReturnType = new TypeToken<PDPConfigResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
