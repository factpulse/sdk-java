/*
 * FactPulse REST API
 *  REST API for electronic invoicing in France: Factur-X, AFNOR PDP/PA, electronic signatures.  ## üéØ Main Features  ### üìÑ Factur-X Invoice Generation - **Formats**: XML only or PDF/A-3 with embedded XML - **Profiles**: MINIMUM, BASIC, EN16931, EXTENDED - **Standards**: EN 16931 (EU directive 2014/55), ISO 19005-3 (PDF/A-3), CII (UN/CEFACT) - **üÜï Simplified Format**: Generation from SIRET + auto-enrichment (Chorus Pro API + Business Search)  ### ‚úÖ Validation and Compliance - **XML Validation**: Schematron (45 to 210+ rules depending on profile) - **PDF Validation**: PDF/A-3, Factur-X XMP metadata, electronic signatures - **VeraPDF**: Strict PDF/A validation (146+ ISO 19005-3 rules) - **Asynchronous Processing**: Celery support for heavy validations (VeraPDF)  ### üì° AFNOR PDP/PA Integration (XP Z12-013) - **Flow Submission**: Send invoices to Partner Dematerialization Platforms - **Flow Search**: View submitted invoices - **Download**: Retrieve PDF/A-3 with XML - **Directory Service**: Company search (SIREN/SIRET) - **Multi-client**: Support for multiple PDP configs per user (stored credentials or zero-storage)  ### ‚úçÔ∏è PDF Electronic Signature - **Standards**: PAdES-B-B, PAdES-B-T (RFC 3161 timestamping), PAdES-B-LT (long-term archival) - **eIDAS Levels**: SES (self-signed), AdES (commercial CA), QES (QTSP) - **Validation**: Cryptographic integrity and certificate verification - **Certificate Generation**: Self-signed X.509 certificates for testing  ### üîÑ Asynchronous Processing - **Celery**: Asynchronous generation, validation and signing - **Polling**: Status tracking via `/tasks/{task_id}/status` - **No timeout**: Ideal for large files or heavy validations  ## üîí Authentication  All requests require a **JWT token** in the Authorization header: ``` Authorization: Bearer YOUR_JWT_TOKEN ```  ### How to obtain a JWT token?  #### üîë Method 1: `/api/token/` API (Recommended)  **URL:** `https://factpulse.fr/api/token/`  This method is **recommended** for integration in your applications and CI/CD workflows.  **Prerequisites:** Having set a password on your account  **For users registered via email/password:** - You already have a password, use it directly  **For users registered via OAuth (Google/GitHub):** - You must first set a password at: https://factpulse.fr/accounts/password/set/ - Once the password is created, you can use the API  **Request example:** ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\"   }' ```  **Optional `client_uid` parameter:**  To select credentials for a specific client (PA/PDP, Chorus Pro, signing certificates), add `client_uid`:  ```bash curl -X POST https://factpulse.fr/api/token/ \\   -H \"Content-Type: application/json\" \\   -d '{     \"username\": \"your_email@example.com\",     \"password\": \"your_password\",     \"client_uid\": \"550e8400-e29b-41d4-a716-446655440000\"   }' ```  The `client_uid` will be included in the JWT and allow the API to automatically use: - AFNOR/PDP credentials configured for this client - Chorus Pro credentials configured for this client - Electronic signature certificates configured for this client  **Response:** ```json {   \"access\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\",  // Access token (validity: 30 min)   \"refresh\": \"eyJ0eXAiOiJKV1QiLCJhbGc...\"  // Refresh token (validity: 7 days) } ```  **Advantages:** - ‚úÖ Full automation (CI/CD, scripts) - ‚úÖ Programmatic token management - ‚úÖ Refresh token support for automatic access renewal - ‚úÖ Easy integration in any language/tool  #### üñ•Ô∏è Method 2: Dashboard Generation (Alternative)  **URL:** https://factpulse.fr/api/dashboard/  This method is suitable for quick tests or occasional use via the graphical interface.  **How it works:** - Log in to the dashboard - Use the \"Generate Test Token\" or \"Generate Production Token\" buttons - Works for **all** users (OAuth and email/password), without requiring a password  **Token types:** - **Test Token**: 24h validity, 1000 calls/day quota (free) - **Production Token**: 7 days validity, quota based on your plan  **Advantages:** - ‚úÖ Quick for API testing - ‚úÖ No password required - ‚úÖ Simple visual interface  **Disadvantages:** - ‚ùå Requires manual action - ‚ùå No refresh token - ‚ùå Less suited for automation  ### üìö Full Documentation  For more information on authentication and API usage: https://factpulse.fr/documentation-api/     
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@factpulse.fr
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Arrays;
import org.openapitools.client.model.AFNORAcknowledgement;
import org.openapitools.client.model.AFNORFlowDirection;
import org.openapitools.client.model.AFNORFlowProfile;
import org.openapitools.client.model.AFNORFlowSyntax;
import org.openapitools.client.model.AFNORFlowType;
import org.openapitools.client.model.AFNORProcessingRule;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.openapitools.client.JSON;

/**
 * The properties of a Flow resource
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-01-15T16:20:25.270629684Z[Etc/UTC]", comments = "Generator version: 7.19.0-SNAPSHOT")
public class AFNORFlow {
  public static final String SERIALIZED_NAME_SUBMITTED_AT = "submittedAt";
  @SerializedName(SERIALIZED_NAME_SUBMITTED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime submittedAt;

  public static final String SERIALIZED_NAME_UPDATED_AT = "updatedAt";
  @SerializedName(SERIALIZED_NAME_UPDATED_AT)
  @javax.annotation.Nullable
  private OffsetDateTime updatedAt;

  public static final String SERIALIZED_NAME_FLOW_ID = "flowId";
  @SerializedName(SERIALIZED_NAME_FLOW_ID)
  @javax.annotation.Nullable
  private String flowId;

  public static final String SERIALIZED_NAME_TRACKING_ID = "trackingId";
  @SerializedName(SERIALIZED_NAME_TRACKING_ID)
  @javax.annotation.Nullable
  private String trackingId;

  public static final String SERIALIZED_NAME_FLOW_TYPE = "flowType";
  @SerializedName(SERIALIZED_NAME_FLOW_TYPE)
  @javax.annotation.Nullable
  private AFNORFlowType flowType;

  public static final String SERIALIZED_NAME_PROCESSING_RULE = "processingRule";
  @SerializedName(SERIALIZED_NAME_PROCESSING_RULE)
  @javax.annotation.Nullable
  private AFNORProcessingRule processingRule;

  /**
   * Says whether the processing rule has been computed or the processing rule was an input parameter
   */
  @JsonAdapter(ProcessingRuleSourceEnum.Adapter.class)
  public enum ProcessingRuleSourceEnum {
    INPUT("Input"),
    
    COMPUTED("Computed");

    private String value;

    ProcessingRuleSourceEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProcessingRuleSourceEnum fromValue(String value) {
      for (ProcessingRuleSourceEnum b : ProcessingRuleSourceEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ProcessingRuleSourceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProcessingRuleSourceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProcessingRuleSourceEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ProcessingRuleSourceEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ProcessingRuleSourceEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_PROCESSING_RULE_SOURCE = "processingRuleSource";
  @SerializedName(SERIALIZED_NAME_PROCESSING_RULE_SOURCE)
  @javax.annotation.Nullable
  private ProcessingRuleSourceEnum processingRuleSource;

  public static final String SERIALIZED_NAME_FLOW_DIRECTION = "flowDirection";
  @SerializedName(SERIALIZED_NAME_FLOW_DIRECTION)
  @javax.annotation.Nullable
  private AFNORFlowDirection flowDirection;

  public static final String SERIALIZED_NAME_FLOW_SYNTAX = "flowSyntax";
  @SerializedName(SERIALIZED_NAME_FLOW_SYNTAX)
  @javax.annotation.Nullable
  private AFNORFlowSyntax flowSyntax;

  public static final String SERIALIZED_NAME_FLOW_PROFILE = "flowProfile";
  @SerializedName(SERIALIZED_NAME_FLOW_PROFILE)
  @javax.annotation.Nullable
  private AFNORFlowProfile flowProfile;

  public static final String SERIALIZED_NAME_ACKNOWLEDGEMENT = "acknowledgement";
  @SerializedName(SERIALIZED_NAME_ACKNOWLEDGEMENT)
  @javax.annotation.Nullable
  private AFNORAcknowledgement acknowledgement;

  public AFNORFlow() {
  }

  public AFNORFlow submittedAt(@javax.annotation.Nullable OffsetDateTime submittedAt) {
    this.submittedAt = submittedAt;
    return this;
  }

  /**
   * The flow submission date and time (the date and time when the flow was created on the system) 
   * @return submittedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getSubmittedAt() {
    return submittedAt;
  }

  public void setSubmittedAt(@javax.annotation.Nullable OffsetDateTime submittedAt) {
    this.submittedAt = submittedAt;
  }


  public AFNORFlow updatedAt(@javax.annotation.Nullable OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
    return this;
  }

  /**
   * The last update date and time of the flow. When the flow is submitted updatedAt is equal to submittedAt. When the flow acknowledgment status is changed updatedAt date and time is updated. 
   * @return updatedAt
   */
  @javax.annotation.Nullable
  public OffsetDateTime getUpdatedAt() {
    return updatedAt;
  }

  public void setUpdatedAt(@javax.annotation.Nullable OffsetDateTime updatedAt) {
    this.updatedAt = updatedAt;
  }


  public AFNORFlow flowId(@javax.annotation.Nullable String flowId) {
    this.flowId = flowId;
    return this;
  }

  /**
   * Unique identifier supporting UUID but not only, for flexibility purpose
   * @return flowId
   */
  @javax.annotation.Nullable
  public String getFlowId() {
    return flowId;
  }

  public void setFlowId(@javax.annotation.Nullable String flowId) {
    this.flowId = flowId;
  }


  public AFNORFlow trackingId(@javax.annotation.Nullable String trackingId) {
    this.trackingId = trackingId;
    return this;
  }

  /**
   * Unique identifier supporting UUID but not only, for flexibility purpose
   * @return trackingId
   */
  @javax.annotation.Nullable
  public String getTrackingId() {
    return trackingId;
  }

  public void setTrackingId(@javax.annotation.Nullable String trackingId) {
    this.trackingId = trackingId;
  }


  public AFNORFlow flowType(@javax.annotation.Nullable AFNORFlowType flowType) {
    this.flowType = flowType;
    return this;
  }

  /**
   * Get flowType
   * @return flowType
   */
  @javax.annotation.Nullable
  public AFNORFlowType getFlowType() {
    return flowType;
  }

  public void setFlowType(@javax.annotation.Nullable AFNORFlowType flowType) {
    this.flowType = flowType;
  }


  public AFNORFlow processingRule(@javax.annotation.Nullable AFNORProcessingRule processingRule) {
    this.processingRule = processingRule;
    return this;
  }

  /**
   * Get processingRule
   * @return processingRule
   */
  @javax.annotation.Nullable
  public AFNORProcessingRule getProcessingRule() {
    return processingRule;
  }

  public void setProcessingRule(@javax.annotation.Nullable AFNORProcessingRule processingRule) {
    this.processingRule = processingRule;
  }


  public AFNORFlow processingRuleSource(@javax.annotation.Nullable ProcessingRuleSourceEnum processingRuleSource) {
    this.processingRuleSource = processingRuleSource;
    return this;
  }

  /**
   * Says whether the processing rule has been computed or the processing rule was an input parameter
   * @return processingRuleSource
   */
  @javax.annotation.Nullable
  public ProcessingRuleSourceEnum getProcessingRuleSource() {
    return processingRuleSource;
  }

  public void setProcessingRuleSource(@javax.annotation.Nullable ProcessingRuleSourceEnum processingRuleSource) {
    this.processingRuleSource = processingRuleSource;
  }


  public AFNORFlow flowDirection(@javax.annotation.Nullable AFNORFlowDirection flowDirection) {
    this.flowDirection = flowDirection;
    return this;
  }

  /**
   * Get flowDirection
   * @return flowDirection
   */
  @javax.annotation.Nullable
  public AFNORFlowDirection getFlowDirection() {
    return flowDirection;
  }

  public void setFlowDirection(@javax.annotation.Nullable AFNORFlowDirection flowDirection) {
    this.flowDirection = flowDirection;
  }


  public AFNORFlow flowSyntax(@javax.annotation.Nullable AFNORFlowSyntax flowSyntax) {
    this.flowSyntax = flowSyntax;
    return this;
  }

  /**
   * Get flowSyntax
   * @return flowSyntax
   */
  @javax.annotation.Nullable
  public AFNORFlowSyntax getFlowSyntax() {
    return flowSyntax;
  }

  public void setFlowSyntax(@javax.annotation.Nullable AFNORFlowSyntax flowSyntax) {
    this.flowSyntax = flowSyntax;
  }


  public AFNORFlow flowProfile(@javax.annotation.Nullable AFNORFlowProfile flowProfile) {
    this.flowProfile = flowProfile;
    return this;
  }

  /**
   * Get flowProfile
   * @return flowProfile
   */
  @javax.annotation.Nullable
  public AFNORFlowProfile getFlowProfile() {
    return flowProfile;
  }

  public void setFlowProfile(@javax.annotation.Nullable AFNORFlowProfile flowProfile) {
    this.flowProfile = flowProfile;
  }


  public AFNORFlow acknowledgement(@javax.annotation.Nullable AFNORAcknowledgement acknowledgement) {
    this.acknowledgement = acknowledgement;
    return this;
  }

  /**
   * Get acknowledgement
   * @return acknowledgement
   */
  @javax.annotation.Nullable
  public AFNORAcknowledgement getAcknowledgement() {
    return acknowledgement;
  }

  public void setAcknowledgement(@javax.annotation.Nullable AFNORAcknowledgement acknowledgement) {
    this.acknowledgement = acknowledgement;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AFNORFlow afNORFlow = (AFNORFlow) o;
    return Objects.equals(this.submittedAt, afNORFlow.submittedAt) &&
        Objects.equals(this.updatedAt, afNORFlow.updatedAt) &&
        Objects.equals(this.flowId, afNORFlow.flowId) &&
        Objects.equals(this.trackingId, afNORFlow.trackingId) &&
        Objects.equals(this.flowType, afNORFlow.flowType) &&
        Objects.equals(this.processingRule, afNORFlow.processingRule) &&
        Objects.equals(this.processingRuleSource, afNORFlow.processingRuleSource) &&
        Objects.equals(this.flowDirection, afNORFlow.flowDirection) &&
        Objects.equals(this.flowSyntax, afNORFlow.flowSyntax) &&
        Objects.equals(this.flowProfile, afNORFlow.flowProfile) &&
        Objects.equals(this.acknowledgement, afNORFlow.acknowledgement);
  }

  @Override
  public int hashCode() {
    return Objects.hash(submittedAt, updatedAt, flowId, trackingId, flowType, processingRule, processingRuleSource, flowDirection, flowSyntax, flowProfile, acknowledgement);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AFNORFlow {\n");
    sb.append("    submittedAt: ").append(toIndentedString(submittedAt)).append("\n");
    sb.append("    updatedAt: ").append(toIndentedString(updatedAt)).append("\n");
    sb.append("    flowId: ").append(toIndentedString(flowId)).append("\n");
    sb.append("    trackingId: ").append(toIndentedString(trackingId)).append("\n");
    sb.append("    flowType: ").append(toIndentedString(flowType)).append("\n");
    sb.append("    processingRule: ").append(toIndentedString(processingRule)).append("\n");
    sb.append("    processingRuleSource: ").append(toIndentedString(processingRuleSource)).append("\n");
    sb.append("    flowDirection: ").append(toIndentedString(flowDirection)).append("\n");
    sb.append("    flowSyntax: ").append(toIndentedString(flowSyntax)).append("\n");
    sb.append("    flowProfile: ").append(toIndentedString(flowProfile)).append("\n");
    sb.append("    acknowledgement: ").append(toIndentedString(acknowledgement)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>(Arrays.asList("submittedAt", "updatedAt", "flowId", "trackingId", "flowType", "processingRule", "processingRuleSource", "flowDirection", "flowSyntax", "flowProfile", "acknowledgement"));

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>(0);
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to AFNORFlow
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!AFNORFlow.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "The required field(s) %s in AFNORFlow is not found in the empty JSON string", AFNORFlow.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!AFNORFlow.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "The field `%s` in the JSON string is not defined in the `AFNORFlow` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("flowId") != null && !jsonObj.get("flowId").isJsonNull()) && !jsonObj.get("flowId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `flowId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("flowId").toString()));
      }
      if ((jsonObj.get("trackingId") != null && !jsonObj.get("trackingId").isJsonNull()) && !jsonObj.get("trackingId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `trackingId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("trackingId").toString()));
      }
      // validate the optional field `flowType`
      if (jsonObj.get("flowType") != null && !jsonObj.get("flowType").isJsonNull()) {
        AFNORFlowType.validateJsonElement(jsonObj.get("flowType"));
      }
      // validate the optional field `processingRule`
      if (jsonObj.get("processingRule") != null && !jsonObj.get("processingRule").isJsonNull()) {
        AFNORProcessingRule.validateJsonElement(jsonObj.get("processingRule"));
      }
      if ((jsonObj.get("processingRuleSource") != null && !jsonObj.get("processingRuleSource").isJsonNull()) && !jsonObj.get("processingRuleSource").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format(java.util.Locale.ROOT, "Expected the field `processingRuleSource` to be a primitive type in the JSON string but got `%s`", jsonObj.get("processingRuleSource").toString()));
      }
      // validate the optional field `processingRuleSource`
      if (jsonObj.get("processingRuleSource") != null && !jsonObj.get("processingRuleSource").isJsonNull()) {
        ProcessingRuleSourceEnum.validateJsonElement(jsonObj.get("processingRuleSource"));
      }
      // validate the optional field `flowDirection`
      if (jsonObj.get("flowDirection") != null && !jsonObj.get("flowDirection").isJsonNull()) {
        AFNORFlowDirection.validateJsonElement(jsonObj.get("flowDirection"));
      }
      // validate the optional field `flowSyntax`
      if (jsonObj.get("flowSyntax") != null && !jsonObj.get("flowSyntax").isJsonNull()) {
        AFNORFlowSyntax.validateJsonElement(jsonObj.get("flowSyntax"));
      }
      // validate the optional field `flowProfile`
      if (jsonObj.get("flowProfile") != null && !jsonObj.get("flowProfile").isJsonNull()) {
        AFNORFlowProfile.validateJsonElement(jsonObj.get("flowProfile"));
      }
      // validate the optional field `acknowledgement`
      if (jsonObj.get("acknowledgement") != null && !jsonObj.get("acknowledgement").isJsonNull()) {
        AFNORAcknowledgement.validateJsonElement(jsonObj.get("acknowledgement"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!AFNORFlow.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'AFNORFlow' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<AFNORFlow> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(AFNORFlow.class));

       return (TypeAdapter<T>) new TypeAdapter<AFNORFlow>() {
           @Override
           public void write(JsonWriter out, AFNORFlow value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public AFNORFlow read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of AFNORFlow given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of AFNORFlow
   * @throws IOException if the JSON string is invalid with respect to AFNORFlow
   */
  public static AFNORFlow fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, AFNORFlow.class);
  }

  /**
   * Convert an instance of AFNORFlow to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

